
# EC2 SSH Keys via Terraform TLS Provider

How to **generate SSH key pairs using the Terraform `tls` provider**, register the **public key** as an **AWS EC2 key pair**, save the **private key** locally with secure permissions, and then launch an EC2 instance that uses the key.

> âš ï¸ **Important security note**: Any secrets generated by Terraform resources (including `tls_private_key`) are **stored in Terraform state**. Keep your state secure (remote backend + encryption + access controls). For production, consider generating keys **outside of Terraform** and only referencing the public key in your configuration.

---

## âœ… What you'll get
- A new SSH key pair generated by Terraform (ED25519 or RSA)
- AWS EC2 key pair created from the **public** key
- Private key written to `~/.ssh/mykey_tls` with `0600` permissions
- EC2 instance launched using that key

---

## ğŸ§© Providers and Versions
Create `versions.tf` (recommended):

```hcl
terraform {
  required_version = ">= 1.6.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 5.0"
    }
    tls = {
      source  = "hashicorp/tls"
      version = ">= 4.0"
    }
  }
}
```

---

## ğŸ” Generate SSH Key with `tls_private_key`
Choose **one** algorithm:

### Option A â€” ED25519 (modern, fast)
```hcl
resource "tls_private_key" "ssh" {
  algorithm = "ED25519"
}
```

### Option B â€” RSA (compatibility)
```hcl
resource "tls_private_key" "ssh" {
  algorithm = "RSA"
  rsa_bits  = 4096
}
```

The resource exposes:
- `private_key_pem` â€” PEMâ€‘encoded private key (**sensitive; ends up in state**)
- `public_key_openssh` â€” OpenSSH formatted public key (safe to upload)

---

## ğŸ—ƒï¸ Save Private Key to Disk (secure permissions)
```hcl
resource "local_file" "private_key" {
  content         = tls_private_key.ssh.private_key_pem
  filename        = pathexpand("~/.ssh/mykey_tls")
  file_permission = "0600"
}
```

> Tip: `pathexpand()` resolves `~` to your home directory. Ensure `~/.ssh` exists.

---

## â˜ï¸ Create AWS EC2 Key Pair from the Public Key
```hcl
resource "aws_key_pair" "this" {
  key_name   = "mykey-tls"
  public_key = tls_private_key.ssh.public_key_openssh
}
```

---

## ğŸŒ Minimal Networking (Default VPC)
```hcl
provider "aws" {
  region = "us-east-1"
}

data "aws_vpc" "default" {
  default = true
}

data "aws_subnets" "default" {
  filter {
    name   = "default-for-az"
    values = ["true"]
  }
}

resource "aws_security_group" "allow_ssh" {
  name   = "allow_ssh_tls"
  vpc_id = data.aws_vpc.default.id

  ingress {
    description = "SSH"
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
```

---

## ğŸ’» Launch EC2 with the TLSâ€‘Generated Key
```hcl
resource "aws_instance" "ec2" {
  ami                         = "ami-0c02fb55956c7d316"  # Replace per region
  instance_type               = "t2.micro"
  subnet_id                   = data.aws_subnets.default.ids[0]
  vpc_security_group_ids      = [aws_security_group.allow_ssh.id]
  key_name                    = aws_key_pair.this.key_name

  tags = {
    Name = "EC2-with-TLS-Key"
  }
}

output "public_ip" {
  value = aws_instance.ec2.public_ip
}
```

---

## ğŸ”‘ Connect via SSH
```bash
ssh -i ~/.ssh/mykey_tls ec2-user@$(terraform output -raw public_ip)
```
(Use `ubuntu` as the username for Ubuntu AMIs.)

---

## ğŸ§° Optional â€” Store Public Key as a Separate File
Sometimes you want a `.pub` file alongside the private key:
```hcl
resource "local_file" "public_key" {
  content         = tls_private_key.ssh.public_key_openssh
  filename        = pathexpand("~/.ssh/mykey_tls.pub")
  file_permission = "0644"
}
```

---

## âš ï¸ Security Caveats & Best Practices
- **State contains private key material**: `tls_private_key.private_key_pem` is stored in state. Use a **remote backend** (e.g., Terraform Cloud/HCP, S3 + DynamoDB) with **encryption at rest** and **strict access controls**.
- Prefer generating keys **outside Terraform** for longâ€‘lived production access, and only reference the public key (`aws_key_pair.public_key`).
- Never commit generated keys (`~/.ssh/mykey_tls` or `*.pem`) to Git.
- Consider **SSM Session Manager** to avoid SSH and public IPs altogether.

---

## ğŸ§ª Full Example File Structure
```
.
â”œâ”€â”€ versions.tf           # provider definitions
â”œâ”€â”€ main.tf               # tls_private_key + local_file + aws_key_pair + ec2
â””â”€â”€ outputs.tf            # public_ip
```

**main.tf** can contain all blocks shown above for a quick start.

---

## ğŸ§­ Troubleshooting
- Permission denied (publickey): ensure you're using the right user (`ec2-user` for Amazon Linux, `ubuntu` for Ubuntu) and the key path is correct.
- Key file permissions: must be `0600` on Unix (`chmod 600 ~/.ssh/mykey_tls`).
- AMI mismatch: pick an AMI ID valid for your region.
- No public IP: either enable public IP or use Session Manager.

---

## âœ… Summary
- Use `tls_private_key` to generate keys in Terraform.
- Save **private** key to disk with `local_file` and `0600` permissions.
- Create AWS EC2 key pair from the **public** key.
- Attach the key to your EC2 with `key_name` and SSH in.
- Be aware of **state exposure**; secure your backend.

---
